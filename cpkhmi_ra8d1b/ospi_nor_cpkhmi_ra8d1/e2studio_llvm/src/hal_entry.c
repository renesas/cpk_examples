/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
 * applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
 * this software. By using this software, you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 *
 * Copyright (C) 2023 Renesas Electronics Corporation. All rights reserved.
 ***********************************************************************************************************************/

#include "hal_data.h"
#include "ospi_b_ep.h"
#include "ospi_b_commands.h"
#include "common_utils.h"

#define CACHE_SIZE (1024 * 128)

void fsp_assert(fsp_err_t err);

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Function declarations*/
void handle_error(fsp_err_t err,  const char *err_str);

static fsp_err_t direct_rw_spi(uint32_t address, uint32_t length, uint8_t width);
static fsp_err_t memory_map_spi(uint32_t address);
static void pretest_spi(void);
static fsp_err_t set_write_enable(uint32_t retry);
static fsp_err_t wait_operation_done(uint32_t retry);

static uint32_t s_cache_w[CACHE_SIZE];

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t           err                         = FSP_SUCCESS;
    fsp_pack_version_t  version                     = {RESET_VALUE};
    uint32_t            flash_id                    = RESET_VALUE;
    uint8_t             rtt_read[BUFFER_SIZE_DOWN]  = {RESET_VALUE};
    uint8_t             * p_ospi_b_address          = NULL;

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT_WAIT;
    APP_PRINT(EP_INFO);
    APP_PRINT_WAIT;

    /* Initialize timer to measure OSPI operation */
    err = timer_init();
    handle_error(err, "timer_init FAILED\r\n");

    /* Initialize OSPI driver module and Flash device in SPI mode */
    err = ospi_b_init();
    handle_error(err, "ospi_b_init FAILED\r\n");

    /* Read Flash device ID */
    err = ospi_b_read_device_id(&flash_id);
    handle_error(err, "ospi_b_read_device_id FAILED\r\n");

    /* Print flash device ID */
    APP_PRINT("\r\nDevice ID read successfully");
    APP_PRINT("\r\nManufacturer ID = 0x%x, Memory Interface Type = 0x%x, Density = 0x%x\r\n",
              (uint8_t)flash_id, (uint8_t)(flash_id >> 8), (uint8_t)(flash_id >> 16));

    // pretest_spi();

    /* Print Main Menu option */
    APP_PRINT(MAIN_MENU);

    /* Main Loop */
    while(true) {
        /* Check new input data from RTT */
        if(APP_CHECK_DATA) {
            /* Clean RTT input buffer */
            memset(rtt_read, RTT_NULL_CHAR, BUFFER_SIZE_DOWN);
        #if 1
            APP_READ(rtt_read);

            /* Handle Main Menu */
            switch(rtt_read[RTT_CHECK_INDEX]) {
            /* Select SPI mode */
            case RTT_SELECT_SPI_MODE_CHAR: {
                /* Set OSPI to SPI mode */
                err = ospi_b_set_protocol_to_spi();
                handle_error(err, "ospi_b_set_protocol_to_spi FAILED\r\n");

                /* Set pointer to flash device memory for SPI operation */
                p_ospi_b_address = OSPI_B_APP_ADDRESS(OSPI_B_SECTOR_FIRST);

                /* Perform OSPI operations */
                err = ospi_b_operation(p_ospi_b_address);
                handle_error(err, "ospi_b_operation FAILED\r\n");
                break;
            }

            /* Select DOPI mode */
            case RTT_SELECT_OPI_MODE_CHAR: {
                /* Set OSPI to OPI mode */
                err = ospi_b_set_protocol_to_opi();
                handle_error(err, "ospi_b_set_protocol_to_opi FAILED\r\n");

                /* Set pointer to flash device memory for OPI operation */
                p_ospi_b_address = OSPI_B_APP_ADDRESS(OSPI_B_SECTOR_SECOND);

                /* Perform OSPI operations */
                err = ospi_b_operation(p_ospi_b_address);
                handle_error(err, "ospi_b_operation FAILED\r\n");
                break;
            }

            /* Invalid input */
            default: {
                APP_PRINT ("\r\nInvalid input. Provide a valid input\r\n");
                break;
            }
            }
        #endif
            /* Print Main Menu option of OSPI operation.*/
            APP_PRINT(MAIN_MENU);
        }
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * Wait until work in progress bit is cleared
 **********************************************************************************************************************/
void ospi_test_wait_until_wip(void)
{
    spi_flash_status_t status;
    status.write_in_progress = true;
    uint32_t timeout = UINT32_MAX;
    while ((status.write_in_progress) && (--timeout > 0)) {
        fsp_assert (R_OSPI_B_StatusGet (&g_ospi_b_ctrl, &status));

    }

    if (0 == timeout) {
        fsp_assert (FSP_ERR_TIMEOUT);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event) {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

/*******************************************************************************************************************//**
 *  @brief       This function handle error if error occurred, closes all opened module, print and traps error.
 *  @param[in]   status    error status
 *  @param[in]   err_str   error string
 *  @retval      None
 **********************************************************************************************************************/
void handle_error(fsp_err_t err,  const char *err_str)
{
    if(FSP_SUCCESS != err) {
        /* Print the error */
        APP_PRINT(err_str);

        /* Close opened OSPI module*/
        if(0U != g_ospi_b_ctrl.open) {
            if(FSP_SUCCESS != R_OSPI_B_Close(&g_ospi_b_ctrl)) {
                APP_ERR_PRINT("R_OSPI_B_Close FAILED\r\n");
            }
        }

        /* Close opened GPT module*/
        if(0U != g_timer_ctrl.open) {
            if(FSP_SUCCESS != R_GPT_Close(&g_timer_ctrl)) {
                APP_ERR_PRINT("R_GPT_Close FAILED\r\n");
            }
        }

        /* Trap the error */
        APP_ERR_TRAP(err);
    }
}

static fsp_err_t direct_rw_spi(uint32_t address, uint32_t length, uint8_t width)
{
    fsp_err_t err;
    spi_flash_direct_transfer_t command;
    uint8_t fail;
    uint32_t i;

    set_write_enable(10);
    command.address = address;
    command.address_length = 4;
    command.command = 0x12;
    command.command_length = 1;
    command.data_length = width;
    command.dummy_cycles = 0;
    for (i = 0; i < length; i++) {
        command.data = i;
        err = R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
        if (err != FSP_SUCCESS) {
            APP_PRINT("%s ==> R_OSPI_B_DirectTransfer() Write Fail: %d\n", __FUNCTION__, err);
            break;
        }
        wait_operation_done(1000);
        set_write_enable(10);
        command.address += width;
    }
    if (err != FSP_SUCCESS) {
        return err;
    }

    fail = 0;
    command.address = address;
    command.address_length = 4;
    command.command = 0x0C;
    command.dummy_cycles = 8;
    for (i = 0; i < length; i++) {
        err = R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
        if (err != FSP_SUCCESS) {
            APP_PRINT("%s ==> R_OSPI_B_DirectTransfer() Read Fail: %d\n", __FUNCTION__, err);
            break;
        }
        if (command.data != i) {
            APP_PRINT("%s ==> Compare Fail: %d\n", __FUNCTION__, i);
            fail = 1;
            break;
        }
        command.address += width;
    }

    if (fail == 0) {
        APP_PRINT("%s ==> Compare Pass\n", __FUNCTION__);
        APP_PRINT("\taddress: 0x%08X\n", address + 0x90000000);
        APP_PRINT("\tlength: %u\n", length);
        APP_PRINT("\twidth: %u\n", width);
    }

    return err;
}

static fsp_err_t memory_map_spi(uint32_t address)
{
    fsp_err_t err;
    uint32_t i, val;

    uint32_t *p32 = (uint32_t *)(0x90000000 + address);

    for (i = 0; i < CACHE_SIZE; i++) {
        s_cache_w[i] = i;
    }

    err = R_OSPI_B_Write(g_ospi_b.p_ctrl, (uint8_t *)s_cache_w, (uint8_t *)p32, CACHE_SIZE * 4);
    if (err != FSP_SUCCESS) {
        APP_PRINT("%s ==> Write Fail, code: %X\n", __FUNCTION__, err);
        return err;
    }

    p32 = (uint32_t *)(0x90000000 + address);
    for (i = 0; i < CACHE_SIZE; i++) {
        val = *p32;
        if (val != i) {
            APP_PRINT("%s ==> Compare fail, at %u\n", __FUNCTION__, i);
            return FSP_ERR_ASSERTION;
        }
        p32++;
    }

    APP_PRINT("%s ==> Compare pass\n", __FUNCTION__);
    APP_PRINT("\taddress: 0x%08X\n", 0x90000000 + address);
    APP_PRINT("\tlength: %d\n", CACHE_SIZE);

    return FSP_SUCCESS;
}

static void pretest_spi(void)
{
    fsp_err_t err;
    spi_flash_direct_transfer_t command;
    uint32_t uid;

    APP_PRINT("================ Enter pretest_spi ================\n");

    /* Note: Reset valid */
    command.address_length = 0;
    command.command = 0x66;
    command.command_length = 1;
    command.data_length = 0;
    command.dummy_cycles = 0;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    command.command = 0x99;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);

    /* Read UID */
    command.address = 0;
    command.address_length = 3;
    command.command = 0x4B;
    command.command_length = 1;
    command.data = 0;
    command.data_length = 2;
    command.dummy_cycles = 8;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    uid = command.data;
    APP_PRINT("%s ==> UID: 0x%X\n", __FUNCTION__, uid);

    /* Check weather in 4-Byte Address mode */
    command.address = 0x00;
    command.address_length = 0;
    command.command = 0x70;
    command.command_length = 1;
    command.data = 0;
    command.data_length = 1;
    command.dummy_cycles = 0;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    if ((command.data & 0x01) == 0x00) {
        APP_PRINT("%s ==> Current in 3-Byte address mode, switch to 4-Byte address mode\n", __FUNCTION__);

        command.command = 0xB7;
        command.data_length = 0;
        R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);

        command.command = 0x70;
        command.data = 0;
        command.data_length = 1;
        R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);

        if ((command.data & 0x01) == 0x00) {
            APP_PRINT("%s ==> Switch to 4-Byte address mode fail, ", __FUNCTION__);
            APP_PRINT("Flag Reg: 0x%X\n", command.data);
        }
    }
    else if (command.data == 0xFE) {
        APP_PRINT("%s ==> Current in 4-Byte address mode\n", __FUNCTION__);
    }
    else {
        APP_PRINT("%s ==> Illegal VCR-AM: 0x%X\n", __FUNCTION__, command.data);
    }

    set_write_enable(10);
    /* 32KB Block Erase */
    command.address = 0;
    command.address_length = 4;
    command.command = 0x5C;
    command.command_length = 1;
    command.data = 0;
    command.data_length = 0;
    command.dummy_cycles = 0;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    wait_operation_done(10000);
    // direct_rw_spi(0, 4096, 4);

    /* 64KB Block Erase Block 0 */
    command.command = 0xDC;
    set_write_enable(10);
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    wait_operation_done(10000);
    /* 64KB Block Erase Block 1 */
    command.address = 0x10000;
    set_write_enable(10);
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    wait_operation_done(10000);
    // direct_rw_spi(0, 20480, 4);

    /* 64KB Block Erase Block 0 */
    command.address = 0;
    set_write_enable(10);
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    wait_operation_done(10000);
    /* 64KB Block Erase Block 1 */
    command.address = 0x10000;
    set_write_enable(10);
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    wait_operation_done(10000);
    memory_map_spi(0);

    /* Set VCR-DC dummy cycle 0x08, 50MHz */
    set_write_enable(10);
    command.address = 0x01;
    command.address_length = 4;
    command.command = 0x81;
    command.command_length = 1;
    command.data = 0x08;
    command.data_length = 1;
    command.dummy_cycles = 0;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    /* Check VCR-DC */
    command.command = 0x85;
    command.data = 0;
    command.dummy_cycles = 8;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    if (command.data != 0x08) {
        APP_PRINT("%s ==> VCR-DC Write Fail, val: %X\n", __FUNCTION__, command.data);
    }

    /* Switch to OSPI */
    set_write_enable(10);
    command.address = 0x00;
    command.command = 0x81;
    command.data = 0xE7;
    command.dummy_cycles = 0;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);

    /* MCU Switch to OSPI */
    err = R_OSPI_B_SpiProtocolSet(g_ospi_b.p_ctrl, SPI_FLASH_PROTOCOL_8D_8D_8D);
    if (err != FSP_SUCCESS) {
        APP_PRINT("%s ==> MCU Set protocol fail, err code: 0x%X\n", __FUNCTION__, err);
    }

    /* Read UID in OSPI mode, confirm successful switch */
    command.address = 0;
    command.address_length = 4;
    command.command = 0x4B4B;
    command.command_length = 2;
    command.data = 0;
    command.data_length = 2;
    command.dummy_cycles = 16;
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    if (command.data != uid) {
        APP_PRINT("%s ==> OSPI Read UID [0x%X] not equal to SPI UID\n", __FUNCTION__, command.data);
    }
    else {
        APP_PRINT("%s ==> UID Compare Pass\n", __FUNCTION__);
    }

    set_write_enable(10);

    APP_PRINT("================ Exit pretest_spi  ================\n");
}

static fsp_err_t set_write_enable(uint32_t retry)
{
    spi_flash_direct_transfer_t command;

    /* Set Write Enable */
    command.address = 0;
    command.address_length = 0;
    command.data = 0;
    command.data_length = 0;
    command.dummy_cycles = 0;
    if (g_ospi_b_ctrl.spi_protocol == SPI_FLASH_PROTOCOL_EXTENDED_SPI) {
        command.command = 0x06;
        command.command_length = 1;
    }
    else {
        command.command = 0x0606;
        command.command_length = 2;
    }
    R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);

    /* Check Write Enable */
    if (g_ospi_b_ctrl.spi_protocol == SPI_FLASH_PROTOCOL_EXTENDED_SPI) {
        command.command = 0x05;
        command.data_length = 1;
    }
    if (g_ospi_b_ctrl.spi_protocol == SPI_FLASH_PROTOCOL_8D_8D_8D) {
        command.command = 0x0505;
        command.command_length = 2;
        command.dummy_cycles = 8;
    }
    while (retry) {
        R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
        if ((command.data & 0x02) == 0) {
            R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);
        }
        else {
            break;
        }
        retry--;
    }
    if (retry == 0) {
        APP_PRINT("%s ==> Set Write Enable Faile\n", __FUNCTION__);
        return FSP_ERR_NOT_ENABLED;
    }

    return FSP_SUCCESS;
}

static fsp_err_t wait_operation_done(uint32_t retry)
{
    spi_flash_direct_transfer_t command;

    command.address_length = 0;
    command.command = 0x05;
    command.command_length = 1;
    command.data = 0;
    command.data_length = 1;
    command.dummy_cycles = 0;
    while (retry) {
        R_OSPI_B_DirectTransfer(g_ospi_b.p_ctrl, &command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
        if (command.data & 0x01) {
            R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);
        }
        else {
            break;
        }
        retry--;
    }
    if (retry == 0) {
        APP_PRINT("%s ==> Wait Operation Timeout\n", __FUNCTION__);
        return FSP_ERR_TIMEOUT;
    }

    return FSP_SUCCESS;
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
