#include "hal_data.h"
//#include "r_ospi_b.h"
#include "common_utils.h"
#include "perf_counter/perf_counter.h"
#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

uint8_t test_data[256];

void fsp_assert(fsp_err_t err);
void ospi_test_wait_until_wip(void);

#define PAGE_SIZE 4096
#define OSPI_BASE_ADDR   (0x80000000UL)
#define OSPI_END_ADDR    (0x90000000UL)  // end exclusive
#define SECTOR_SIZE      (0x1000UL)      // 4KB

#define TOTAL_SIZE       (OSPI_END_ADDR - OSPI_BASE_ADDR)
#define WRITE_SIZE       (64U)
#define TEST_SIZE        (256U)

static uint8_t __attribute__((aligned(8))) speed_test_data[PAGE_SIZE];

static spi_flash_cfg_t s_ospi0_cfg_fix;

uint32_t ms_for_256MB;
uint32_t test_cnt = 0;

static fsp_err_t qspi_benchmark_test(char *mode, uint32_t taddr, uint32_t tsize)
{
    int i;
    fsp_err_t err;
    uint32_t ms, speed;
    volatile uint32_t data;

    uint8_t *dest = (uint8_t *)taddr;
    uint32_t test_size = tsize;
    FSP_CRITICAL_SECTION_DEFINE;

    APP_PRINT("QSPI (%s) Read/Write speed test start, please wait...\n", mode);

    for (i = 0; i < PAGE_SIZE; i++)
        speed_test_data[i] = (uint8_t)i % 256;

    APP_PRINT("write data to qspi ...\n");
    ms = (uint32_t)get_system_ms();
    for (i = 0; i < (int)test_size / PAGE_SIZE; i++) {
        FSP_CRITICAL_SECTION_ENTER;
        err = R_OSPI_B_Write(g_ospi0.p_ctrl, speed_test_data, dest, PAGE_SIZE);
        FSP_CRITICAL_SECTION_EXIT;
        if (err != FSP_SUCCESS) {
            APP_PRINT("%s: Write %d bytes to 0x%x fail %d.\n",
                    __func__, PAGE_SIZE, (uint32_t)dest, err);
            return err;
        }

        ospi_test_wait_until_wip();
        dest += PAGE_SIZE;
    }
    ms = (uint32_t)get_system_ms() - ms;
    speed = ((test_size >> 10) * 1000) / ms;
    APP_PRINT("\nQSPI flash 4K write speed (use %ums): %u KB/s\n", ms, speed);

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x80000000, 256);
#endif

    APP_PRINT("read data to qspi ...\n");
    ms = (uint32_t)get_system_ms();
    for (i = 0; i < (int)(test_size / sizeof(uint32_t)); i++) {
        data = *(uint32_t *)dest;
        dest += sizeof(uint32_t);
    }
    ms = (uint32_t)get_system_ms() - ms;
    speed = ((test_size >> 10) * 1000) / ms;
    APP_PRINT("\nQSPI flash read speed (use %ums): %u KB/s\n", ms, speed);

    return 0;
}

static void do_benchmark_test(char *mode, uint32_t taddr, uint32_t tsize)
{
    fsp_err_t err = FSP_SUCCESS;
    uint32_t ms;

    APP_PRINT("erase chip under %s, please wait\n", mode);
    ms = get_system_ms();
    err = R_OSPI_B_Erase (g_ospi0.p_ctrl, (uint8_t *)0x80000000, SPI_FLASH_ERASE_SIZE_CHIP_ERASE);
    fsp_assert (err);
    ospi_test_wait_until_wip ();
    ms = get_system_ms() - ms;
    APP_PRINT("erase chip done under %s. use %us\n", mode, ms / 1000);

    qspi_benchmark_test(mode, taddr, tsize);
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    spi_flash_direct_transfer_t direct_command;
    FSP_CRITICAL_SECTION_DEFINE;

    APP_PRINT("-----------------> Start QSPI flash test case.\n");

    init_cycle_counter(false);

    uint8_t *dest = (uint8_t*) 0x80000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        test_data[i] = (uint8_t) i;
    }

    err = R_OSPI_B_Open (g_ospi0.p_ctrl, g_ospi0.p_cfg);
    fsp_assert (err);
    memcpy(&s_ospi0_cfg_fix, &g_ospi0_cfg, sizeof(g_ospi0_cfg));
    g_ospi0_ctrl.p_cfg = &s_ospi0_cfg_fix;

    // CS0
    R_XSPI0->LIOCFGCS_b[0].SDRSMPMD = 0x1;

    /* Enable Reset */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x66;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    /* Reset Device */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x99;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    R_BSP_SoftwareDelay(30, BSP_DELAY_UNITS_MICROSECONDS);

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0xC7;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip ();

    /* Erase sector 0x0 via 1S-1S-1S protocol */
    err = R_OSPI_B_Erase (g_ospi0.p_ctrl, dest, 0x1000);
    fsp_assert (err);
    ospi_test_wait_until_wip ();

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

#if 1
    dest = (uint8_t*) 0x80000000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x80000000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif
    APP_PRINT("-----------------> Write to 0x80000000\n");
#if 1
    dest = (uint8_t*) 0x80040000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x80040000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif
    APP_PRINT("-----------------> Write to 0x80040000\n");

    char ch = 0;
    APP_PRINT("Enter 1 to start QSPI (1S-1S-1S) read/write speed test.\n");
    while (SEGGER_RTT_Read(0, &ch, 1) == 0);
    if (ch == '1') {

        do_benchmark_test("1S-1S-1S", 0x80000000, 0x400000);
    }

    err = R_OSPI_B_SpiProtocolSet(g_ospi0.p_ctrl, SPI_FLASH_PROTOCOL_1S_4S_4S);
    fsp_assert (err);
    //clean rtt
    while (SEGGER_RTT_Read(0, &ch, 1) > 0) { }


#if 0
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x80000000, 256);
#endif
    dest = (uint8_t*) 0x80000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

#if 0
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x80040000, 256);
#endif
    dest = (uint8_t*) 0x80040000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

    APP_PRINT("Enter 2 to start QSPI (1S-4S-4S) read/write speed test.\n");
    while (SEGGER_RTT_Read(0, &ch, 1) == 0);
    if (ch == '2') {
        s_ospi0_cfg_fix.write_enable_bit = 5;
        qspi_benchmark_test("1S-4S-4S", 0x80000000, 0x400000);
    }


    // happy path
    __BKPT(0);

    /* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void fsp_assert(fsp_err_t err)
{
    if (FSP_SUCCESS != err)
    {
        __BKPT(0);
    }
}

/*******************************************************************************************************************//**
 * Wait until work in progress bit is cleared
 **********************************************************************************************************************/
void ospi_test_wait_until_wip(void)
{
    spi_flash_status_t status;
    status.write_in_progress = true;
    uint32_t timeout = UINT32_MAX;
    while ((status.write_in_progress) && (--timeout > 0))
    {
        fsp_assert (R_OSPI_B_StatusGet (g_ospi0.p_ctrl, &status));
    }

    if (0 == timeout)
    {
        fsp_assert (FSP_ERR_TIMEOUT);
    }
}


#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
