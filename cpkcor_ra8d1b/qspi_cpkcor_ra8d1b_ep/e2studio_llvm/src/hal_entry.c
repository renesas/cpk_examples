/*
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
*/

#include "hal_data.h"
#include "common_utils.h"
#include "perf_counter/perf_counter.h"

#define LED1_ON     R_PORT4->PCNTR3_b.POSR = (1 << 9)  // LED_LD9  On,  High
#define LED1_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 9)  // LED_LD9  Off, Low
#define LED2_ON     R_PORT4->PCNTR3_b.POSR = (1 << 10) // LED_LD10 On,  High
#define LED2_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 10) // LED_LD10 Off, Low
#define LED3_ON     R_PORT4->PCNTR3_b.POSR = (1 << 11) // LED_LD11 On,  High
#define LED3_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 11) // LED_LD11 Off, Low
#define LED4_ON     R_PORT4->PCNTR3_b.POSR = (1 << 12) // LED_LD12 On,  High
#define LED4_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 12) // LED_LD12 Off, Low

uint8_t test_data[256];
uint8_t Flash_Type = 0;
#define AT25SF128A    (1)
#define W25Q128JVPIQ  (2)
#define W25Q128JW     (3)

void fsp_assert(fsp_err_t err);
void ospi_test_wait_until_wip(void);

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

#define PAGE_SIZE 4096
static uint8_t __attribute__((aligned(8))) speed_test_data[PAGE_SIZE];

static spi_flash_cfg_t s_ospi0_cfg_fix;
static bsp_octaclk_settings_t s_octclk;

static fsp_err_t qspi_benchmark_test(char *mode, uint32_t taddr, uint32_t tsize)
{
    int i;
    fsp_err_t err;
    uint32_t ms, speed;
	volatile uint32_t data;

	uint8_t *dest = (uint8_t *)taddr;
	uint32_t test_size = tsize;
	FSP_CRITICAL_SECTION_DEFINE;

	APP_PRINT("QSPI (%s) Read/Write speed test start, please wait...\n", mode);

	for (i = 0; i < PAGE_SIZE; i++)
		speed_test_data[i] = (uint8_t)i % 256;

	APP_PRINT("write data to qspi ...\n");
	ms = (uint32_t)get_system_ms();
	for (i = 0; i < (int)test_size / PAGE_SIZE; i++) {
		FSP_CRITICAL_SECTION_ENTER;
		err = R_OSPI_B_Write(g_ospi0.p_ctrl, speed_test_data, dest, PAGE_SIZE);
		FSP_CRITICAL_SECTION_EXIT;
		if (err != FSP_SUCCESS) {
			APP_PRINT("%s: Write %d bytes to 0x%x fail %d.\n",
					__func__, PAGE_SIZE, (uint32_t)dest, err);
			return err;
		}

		ospi_test_wait_until_wip();
		dest += PAGE_SIZE;
	}
	ms = (uint32_t)get_system_ms() - ms;
	speed = ((test_size >> 10) * 1000) / ms;
	APP_PRINT("\nQSPI flash 4K write speed (use %ums): %u KB/s\n", ms, speed);

#if BSP_CFG_DCACHE_ENABLED
	SCB_InvalidateDCache_by_Addr((volatile void *)0x90000000, 256);
#endif

	APP_PRINT("read data to qspi ...\n");
	ms = (uint32_t)get_system_ms();
	for (i = 0; i < (int)(test_size / sizeof(uint32_t)); i++) {
		data = *(uint32_t *)dest;
		dest += sizeof(uint32_t);
	}
	ms = (uint32_t)get_system_ms() - ms;
	speed = ((test_size >> 10) * 1000) / ms;
	APP_PRINT("\nQSPI flash read speed (use %ums): %u KB/s\n", ms, speed);

	return 0;
}

static void do_benchmark_test(char *mode, uint32_t taddr, uint32_t tsize)
{
    fsp_err_t err = FSP_SUCCESS;
    uint32_t ms;

    APP_PRINT("erase chip under %s, please wait\n", mode);
    ms = get_system_ms();
    err = R_OSPI_B_Erase (g_ospi0.p_ctrl, (uint8_t *)0x90000000, SPI_FLASH_ERASE_SIZE_CHIP_ERASE);
    fsp_assert (err);
    ospi_test_wait_until_wip ();
    ms = get_system_ms() - ms;
    APP_PRINT("erase chip done under %s. use %us\n", mode, ms / 1000);

    qspi_benchmark_test(mode, taddr, tsize);
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    spi_flash_direct_transfer_t direct_command;
    FSP_CRITICAL_SECTION_DEFINE;

    APP_PRINT("-----------------> Start QSPI flash test case.\n-------------->");

    init_cycle_counter(false);

    uint8_t *dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        test_data[i] = (uint8_t) i;
    }

    err = R_OSPI_B_Open (g_ospi0.p_ctrl, g_ospi0.p_cfg);
    fsp_assert (err);
    memcpy(&s_ospi0_cfg_fix, &g_ospi0_cfg, sizeof(g_ospi0_cfg));
    g_ospi0_ctrl.p_cfg = &s_ospi0_cfg_fix;

    R_XSPI0->LIOCFGCS_b[1].SDRSMPMD = 0x1;

    /* Enable Reset */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x66;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    /* Reset Device */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x99;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    R_BSP_SoftwareDelay(30, BSP_DELAY_UNITS_MICROSECONDS);

    /* Check Manufacture/Device ID via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x90;
    direct_command.command_length = 0x1;
    direct_command.address        = 0x0000;//0x000000;
    direct_command.address_length = 0x2;//0x3;
    direct_command.dummy_cycles   = 0x8;//0;
    direct_command.data_length    = 0x2;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    fsp_assert (err);

    if((direct_command.data == 0xEF17) || (direct_command.data == 0x17EF))//For CPKCOR W25Q128JVPIQ
    {
        Flash_Type = W25Q128JVPIQ;
    }
    else if((direct_command.data == 0x1F17) || (direct_command.data == 0x171F)|| (direct_command.data == 0x8b0F))//For CPKCOR AT25SF128A
    {
        Flash_Type = AT25SF128A;
    }
    else if((direct_command.data == 0xEF18) || (direct_command.data == 0x18EF))//For CPKDIS W25Q128JW
    {
        Flash_Type = W25Q128JW;
    }
    else
    {
        __BKPT(0);
    }

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0xC7;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip ();

    /* Erase sector 0x0 via 1S-1S-1S protocol */
    err = R_OSPI_B_Erase (g_ospi0.p_ctrl, dest, 0x1000);
    // err = R_OSPI_B_Erase (g_ospi0.p_ctrl, dest, 0x100000);
    fsp_assert (err);
    ospi_test_wait_until_wip ();

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

#if 1
    dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90000000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif
#if 1
    dest = (uint8_t*) 0x90040000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90040000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

    char ch = 0;
    APP_PRINT("Enter 1 to start QSPI (1S-1S-1S) read/write speed test.\n");
    while (SEGGER_RTT_Read(0, &ch, 1) == 0);
    if (ch == '1') {
        if (Flash_Type == AT25SF128A) {
            s_octclk.divider = BSP_CLOCKS_OCTACLK_DIV_4;
            s_octclk.source_clock = BSP_CFG_OCTACLK_SOURCE;
            R_BSP_OctaclkUpdate(&s_octclk);
        }
	    do_benchmark_test("1S-1S-1S", 0x90000000, 0x400000);
	    if (Flash_Type == AT25SF128A) {
	        s_octclk.divider = BSP_CFG_OCTACLK_DIV;
            s_octclk.source_clock = BSP_CFG_OCTACLK_SOURCE;
            R_BSP_OctaclkUpdate(&s_octclk);
	    }
    }

    //For CPKCOR AT25SF128A
    if (AT25SF128A == Flash_Type)
    {
        /* Read Status Register Byte 2 */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x35;
        direct_command.command_length = 0x1;
        direct_command.address        = 0x0;
        direct_command.address_length = 0x0;
        direct_command.dummy_cycles   = 0x0;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
        fsp_assert (err);

        /* Set Write Enable for Volatile Status Register via 1S-1S-1S protocol */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x50;
        direct_command.command_length = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
        fsp_assert (err);
        ospi_test_wait_until_wip();

        /* Set QE bit to 1 to enable Quad */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x31;
        direct_command.command_length = 0x1;
        direct_command.data           = 0x02;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
        fsp_assert (err);

        /* Read Status Register Byte 2 */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x35;
        direct_command.command_length = 0x1;
        direct_command.address        = 0x0000;
        direct_command.address_length = 0x0;
        direct_command.dummy_cycles   = 0x0;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    }

    err = R_OSPI_B_SpiProtocolSet(g_ospi0.p_ctrl, SPI_FLASH_PROTOCOL_1S_4S_4S);
    fsp_assert (err);

    /* Check Manufacture/Device ID via 1S-4S-4S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x94;
    direct_command.command_length = 0x1;
    direct_command.address        = 0x000000;
    direct_command.address_length = 0x3;
    direct_command.dummy_cycles   = 0x6;
    direct_command.data_length    = 0x2;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    fsp_assert (err);

    if (Flash_Type == AT25SF128A) {
        if(!((direct_command.data == 0x1F17) || (direct_command.data == 0x171F))) {
            __BKPT(0);
        }
    }
    else {
        if(!((direct_command.data == 0xEF17) || (direct_command.data == 0x17EF))) {
            __BKPT(0);
        }
    }

#if 0
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90000000, 256);
#endif
    dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

#if 0
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90040000, 256);
#endif
    dest = (uint8_t*) 0x90040000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

    APP_PRINT("Enter 1 to start QSPI (1S-4S-4S) read/write speed test.\n");
    while (SEGGER_RTT_Read(0, &ch, 1) == 0);
    if (ch == '1') {
        s_ospi0_cfg_fix.write_enable_bit = 5;
	    qspi_benchmark_test("1S-4S-4S", 0x90000000, 0x400000);
    }

    // happy path
    __BKPT(0);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void fsp_assert(fsp_err_t err)
{
    if (FSP_SUCCESS != err)
    {
        LED3_ON;
        __BKPT(0);
    }
}

/*******************************************************************************************************************//**
 * Wait until work in progress bit is cleared
 **********************************************************************************************************************/
void ospi_test_wait_until_wip(void)
{
    spi_flash_status_t status;
    status.write_in_progress = true;
    uint32_t timeout = UINT32_MAX;
    while ((status.write_in_progress) && (--timeout > 0))
    {
        fsp_assert (R_OSPI_B_StatusGet (g_ospi0.p_ctrl, &status));
    }

    if (0 == timeout)
    {
        fsp_assert (FSP_ERR_TIMEOUT);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &IOPORT_CFG_NAME);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
