:imagesdir: images

:sectnums:
:sectnumlevels: 2

= RA8T2程序/数据存储位置对性能的影响评测样例

:toc:
:toc-title: 目录

RA8T2 有多个内存区域可以存放代码和数据，并支持指令缓存（I-Cache）和数据缓存（D-Cache）。
该样例工程以 Coremark 为测试基准，通过将代码和数据放在不同区域、缓存配置是否开启来展示不同配置对CPU性能的影响。

注意：CoreMark测试并不支持CM85内核的Helium指令，仅提供CPU标量运算性能的参考。

== 工程配置和切换

示例工程使用了两个编译配置，分别为 Debug 和 Release，可以按下图所示切换。

二者的区别在于：

* Debug 配置下编译生成调试信息，可以较为方便的进行调试; Release 没有生成调试信息
* Debug 配置下使用 RTT View 输入输出; Release 使用 UART 输入输出，UART 波特率 2000000，8bit 数据位，1bit 停止位，无奇偶校验
* Debug 配置下使用e2studio的调试功能进行程序的烧录调试；Release 配置下生成程序镜像文件，可以使用烧录工具进行烧录。
    ** 有关如何烧录编译好的镜像文件，请参考link:../../docs/ra8_nvm_programming.adoc[RA8 MCU的程序烧录]

image::Snipaste_2026-01-09_10-41-17_01.png[role="thumb", width=800]

=== 预定义宏选项

示例工程可以使用下图中红色方框中的预定义宏来决定代码和变量存储位置以及 Cache 功能。

image::Snipaste_2026-01-19_13-43-05.png[role="thumb"]

* __CODE_AREA: 设定 `CODE_AREA` 的值，控制被修饰的程序代码运行的位置
* __DATA_AREA: 设定 `DATA_AREA_BSS`、`DATA_AREA_DATA`、`DATA_AREA_ZERO` 的值，控制被修饰的变量存储的位置

[cols="~,~,~", options="header"]
|====
^| 宏定义         ^| 定义值       | 存储位置    
.4+^.^| __CODE_AREA | 未定义       | 被CODE_AREA修饰的函数代码在MRAM中运行                                                     
         | CODE_MRAM | 被CODE_AREA修饰的函数代码在MRAM中运行                                                     
         | CODE_ITCM | 被CODE_AREA修饰的函数代码在CPU0的I-TCM中运行                                               
         | 其他值       | 编译错误                                                                
.4+^.^| __DATA_AREA | 未定义       | 被`DATA_AREA_BSS`、`DATA_AREA_DATA`或`DATA_AREA_ZERO`修饰的变量存储在SRAM      
         | DATA_SRAM | 被`DATA_AREA_BSS`、`DATA_AREA_DATA`或`DATA_AREA_ZERO`修饰的变量存储在SRAM      
         | DATA_DTCM | 被`DATA_AREA_BSS`、`DATA_AREA_DATA`或`DATA_AREA_ZERO`修饰的变量存储在CPU0的D-TCM
        | 其他值       | 编译错误 
|====

注意：未被修饰的函数和数据，使用FSP的缺省配置，即使用MRAM和SRAM。

* BSP_CFG_DCACHE_ENABLED: 决定是否开启 DCache 功能
** `BSP_CFG_DCACHE_ENABLED=1`: 开启 DCache
** `BSP_CFG_DCACHE_ENABLED=0`: 关闭 DCache
** 未定义: 由 FSP Configuration 决定，#FSP缺省未开启D-Cache#
* BSP_CFG_DCACHE_FORCE_WRITETHROUGH: 决定 DCache 的工作模式，开启 DCache后该配置才起效
** `BSP_CFG_DCACHE_FORCE_WRITETHROUGH=1`: DCache 工作在 Write Through 模式
** `BSP_CFG_DCACHE_FORCE_WRITETHROUGH=0`: DCache 工作在 Write Back 模式
** 未定义: 由 FSP Configuration 决定，缺省为Write Back 模式

下面是在上图所示配置下的运行结果

image::Snipaste_2026-01-19_13-32-43.png[role="thumb"]

=== 参考结果

使用本样例程序进行不同配置的评测，得到如下参考结果：

* FSP配置中，缺省开启I-Cache，下表中不再详述
** 如果担心I-Cache会造成指令执行的时间不确定，请使用I-TCM
** #请不要手动禁用I-Cache#，会造成性能暴跌

[cols="12,12,18,~,~", options="header"]
|====
| 代码运行  | 数据存储 | D-Cache设置     | Coremark | 说明                                         
| I-TCM | D-TCM | Write-Back    ^| 4.24     | 推荐有时间确定性和高性能要求的代码使用 (如特定的ISR，需要频繁调用的算法等)          
5+|                                             
| MRAM  | SRAM | OFF           ^| 0.46     | 一定要打开D-Cache，否则性能暴跌
| MRAM  | SRAM | Write-Back    ^| 4.21     | 推荐日常使用                  
| MRAM  | SRAM | Write-Through ^| 3.86     | Cache WT会有10%左右的性能孙淑
5+|                                          
| MRAM  | D-TCM | OFF           ^| 2.63     .3+| D-Cache对D-TCM本身不起作用，但即使用D-TCM，也请不要禁用D-Cache。（您程序的数据可能并不全在定义的数据段）
| MRAM  | D-TCM | Write-Back    ^| 4.24       
| MRAM  | D-TCM | Write-Through ^| 4.23      
|====


== 测量其用户代码的运行时间

应用程序入口在 hal_entey.c 中的 `hal_entey()` 函数，示例工程的函数主要内容如下：

[source,c,subs="verbatim,attributes"]
----
printf("Input any character to start coremark\r\n");
while (1) {
    R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    if (CONSOLE_HasData()) {
        break;
    }
    else {
        printf("Input any character to start coremark\r\n");
    }
}
printf("Coremark running, please wait...\r\n");
__cpu_perf__("Coremark") {
    coremark_main(&s_core_param);
};
coremark_report(&s_core_param);
----

要测量用户代码，只需将要测量部分放进 `+__cpu_perf__+` 的花括号内。例如，假设要测量如下一个函数的运行时间

[source,c,subs="verbatim,attributes"]
----
DATA_AREA_DATA static int s_loop_num; //定义全局变量，用DATA_AREA_DATA修饰
CODE_AREA void foo(void)   //foo() 函数用CODE_AREA修饰
{
	while (s_loop_num--) {
		__asm__ volatile (
			"NOP"         //此处演示程序使用inline汇编，防止被编译器优化
		);
	}
}
----

那么对 hal_entry() 做如下修改

[source,c,subs="verbatim,attributes"]
----
printf("Input any character to start coremark\r\n");
while (1) {
    R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    if (CONSOLE_HasData()) {
        break;
    }
    else {
        printf("Input any character to start coremark\r\n");
    }
}
printf("foo() running, please wait...\r\n");
__cpu_perf__("foo") {
    // coremark_main(&s_core_param);
    s_loop_num = 100000000;
    foo();
};
// coremark_report(&s_core_param);
----

在前述Release配置下编译烧录后，运行结果如下：

image::Snipaste_2026-01-16_15-31-05.png[role="thumb"]
