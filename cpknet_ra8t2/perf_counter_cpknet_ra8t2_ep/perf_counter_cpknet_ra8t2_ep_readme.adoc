:imagesdir: images
:sectnums:
:sectnumlevels: 2

= perf_counter性能测试工程使用说明
:toc:
:toc-title: 目录

== 简介

此样例工程集成了perf_counter性能测试工具，并通过运行CoreMark®程序来测试不同编译器和编译配置下，RA8T2的Cortex M85内核的性能，该性能数据可以作为编译器和编译参数选择的一个参考。

CoreMark测试并不支持CM85内核的Helium指令，仅提供CPU标量运算性能的参考。

本样例程序CoreMark的测试代码运行在I-TCM中，数据使用D-TCM，最大限度排除了片内存储器和总线对测试结果的影响。

样例程序包含三个目录，对应FSP 6.3.0可以支持的三种编译器和对应的集成开发环境

* e^2^studio 2025-12 + LLVM 21.1.1
* e^2^studio 2025-12 + GCC 13.2.1
* Keil MDK 5.42 + ARM Compiler 6.23 (通过RASC生成MDK工程)

本工程也可作为一个基础测试框架，对用户程序进行性能测试。有关如何设置工程并加入用户代码进行测试，请参以下文档：

link:perf_counter_addusercode_e2.adoc[e^2^studio - 基于perf_counter工程进行用户代码性能测试]

link:perf_counter_addusercode_mdk.adoc[Keil MDK - 基于perf_counter工程进行用户代码性能测试]


== 快速查看测试结果

在 `perf_counter_cpknet_ra8t2_ep` 文件夹下已提供三个编译好的 hex 文件，分别对应三种环境，可以用瑞萨的RFP烧录工具或Segger的J-Flash Lite烧录后运行。其中使用 e^2^studio 开发环境的工程均使用 Release 配置编译生成，性能表现均会优于 Debug 配置。

有关如何烧录编译好的镜像文件，请参考link:../../docs/ra8_nvm_programming.adoc[RA8 MCU的程序烧录]

* #perf_counter_llvm_release.hex# : e^2^studio + llvm 21.1.1
* #perf_counter_gcc_release.hex# : e^2^studio + arm-none-eabi-gcc 13.2.1.arm-13-7
* #perf_counter_keil.hex# : Keil MDK + ARMCC6.23

样例程序Release配置的优化级别和性能测试结果如下：
[%autowidth, options="header"]
|====
| 编译器               | 优化选项   | 代码大小 | 测试成绩  | CoreMark/MHz   
| LLVM (ATfE) 21.1.1   | -O3 -flto |  #4254#    | 4330.41 | 4.33  
| GCC 13.2.1.arm-13-7  | -O3       | 8984    | 4909.48 | 4.91  
| Arm Compiler 6.23  | -Omax --lto | 9066    | 6289.80 | #6.29#  
|====

* 测试结果使用 UART 输出，使用RA8T2的SCI9。SCI9在核心板上连接到了J-Link OB的USB转串口输出
* PC端选择J-Link的串口，设置波特率 2000000，8bit 数据位，1bit 停止位，无奇偶校验。
* 输出信息使用UTF-8编码，其中含有中文字符，建议使用支持 UTF-8 编码的串口终端工具，例如 Putty。
* 输出结果中包含了由perf_counter工具统计的运行CPU周期数。

.展开查看perf_counter_llvm_release.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-08_17-03-43.png[width=640, height=480]
====

.展开查看perf_counter_gcc_release.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-09_09-59-22.png[width=640, height=480]
====

.展开查看perf_counter_keil.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-08_17-10-10.png[width=640, height=480]
====

== 在Release配置下修改编译优化选项

通过修改各个工程使用的编译优化选项，可以得出在不同优化等级下CoreMark测试结果。
每次运行的结果可能有细微差异，下表供参考：

[%autowidth, options="header"]
|=====
| 编译器 | 优化选项            | 代码大小  | 测试成绩        | Coremark/MHz
.7+.^| LLVM 21.1.1   | -O0             | 8168  | 1052.188552 | 1.05    
        | -O1             | 6616  | 4109.729785 | 4.11    
        | -O2             | 8448  | 4168.837936 | 4.17    
        | -O3             | 8880  | 4229.894781 | 4.23    
        | -O3 -flto       | #4254#  | 4330.175913 | #4.33#    
        | -Os             | 5276  | 4159.733777 | 4.16    
        | -Oz             | #4130#  | 3615.002259 | 3.62    
.7+.^| GCC 13.2.1   | -O0             | 8816  | 939.044288  | 0.94    
        | -O1             | 5200  | 3650.800894 | 3.65    
        | -O2             | 5992  | 4654.680863 | 4.65    
        | -O3             | 8984  | 4919.14161  | #4.92#    
        | -Os             | #4272#  | 3602.46769  | 3.60    
        | -Ofast          | 8984  | 4918.839154 | #4.92#    
        | -Oz             | 4272  | 3602.305476 | 3.60    
.8+.^| AC 6.23   | -O0             | 8120  | 1062.741608 | 1.06    
        | -O1             | 6536  | 4067.934506 | 4.07    
        | -O2             | 10040 | 4367.527434 | 4.37    
        | -O3             | 10144 | 5607.738679 | 5.61    
        | -Ofast          | 10680 | 5607.738679 | 5.61    
        | -Os             | 5308  | 4078.719282 | 4.08    
        | -Oz             | #4284#  | 3747.248115 | 3.75    
        | -Omax --lto     | 9066  | 6286.34292  | #6.29#    
|=====

如果您有兴趣自己复现一下测试结果，请按下面的流程修改编译优化选项。

=== 使用e^2^studio + llvm 或 gcc

其中 e2studio_gcc 和 e2studio_llvm 都是使用 e2 studio 进行管理和构建的，只是使用的编译器不同。有关工程的配置都一样，因此只以 e2studio_llvm 为例说明如何使用，对于 e2studio_gcc，大部分步骤都一样，只对差异部分做说明。

==== 导入工程并通过FSP生成工程文件

导入后先双击工程目录下的 configuration.xml 打开 FSP Configuration，这里不需要对里面的配置做任何改动，直接点击右上角的 `Generate Project Content` 生成工程文件即可

image::Snipaste_2026-01-09_10-35-03.png[role="thumb", width=800]

==== LLVM编译器修改优化选项

在工程的 C/C++ 属性设置界面中的 Optimization 选项，通过 Optimization Level 选择优化级别。

image::Snipaste_2026-01-13_10-06-36.png[role="thumb", width=800]

对于 LLVM 编译器，还有一个链接时优化选项可选，该选项也在 Optimization 中，若要使用，勾选 Link-time optimizer(-flto) 选项即可

image::Snipaste_2026-01-13_10-09-09.png[role="thumb", width=800]

==== GCC编译器修改优化选项

在工程的 C/C++ 属性设置界面中的 Optimization 选项，通过 Optimization Level 选择优化级别。

image::Snipaste_2026-01-13_10-12-14.png[role="thumb", width=800]

==== 构建工程并烧录镜像文件

点击 e^2^studio 左上角的锤子图标构建工程

image::Snipaste_2026-01-09_10-39-18_01.png[role="thumb", width=400]

下方控制台会输出编译信息

image::Snipaste_2026-01-09_10-39-18_02.png[role="thumb", width=640]

编译生成的 hex 文件在工程目录的 Release 文件夹下，可以通过烧录器烧录。

image::Snipaste_2026-01-13_15-35-26.png[role="thumb", width=800]

=== Keil MDK + ac6

==== RASC 打开工程

MDK 工程需要先使用 RASC 生成。打开 RASC，点击左上角的 `File` -> `Open`，然后选择到工程目录下的 `configuration.xml`

image::Snipaste_2026-01-09_13-36-36.png[role="thumb", width=320]

之后会进入以下界面，在该界面无需任何配置，直接点击右上角的 `Generate Project Content` 即可

image::Snipaste_2026-01-09_13-40-02.png[role="thumb", width=800]

==== 修改编译优化选项

编译选项在 `via/rasc_armclang.via` 和 `via/rasc_armlink.via` 中修改，*在 keil 里选择是无效的，这两个文件的优先级高于 keil 里的设置*。并且要注意，每次使用 RASC 生成，这两个文件都会被覆盖，因此需要注意这两个文件的修改是否被 RASC 覆盖。如下图，为 RASC 生成后的默认选项

image::Snipaste_2026-01-09_14-55-25.png[role="thumb", width=800]

要获得最高运行速度，可以将优化选项改为 `-Omax`，链接选项中添加 `--lto` 获得最高的优化等级

image::Snipaste_2026-01-09_14-56-35.png[role="thumb", width=800]

==== 构建工程

点击左上角的符号进行构建

image::Snipaste_2026-01-09_13-47-31.png[role="thumb", width=400]

==== 烧录 hex 文件并运行

Keil 生成的 hex 文件在工程目录下的 `Objects/perf_counter_keil.hex`，可以直接使用烧录工具烧录

image::Snipaste_2026-01-13_15-32-41.png[role="thumb", width=800]

== 添加用户程序进行性能测试

需要使用本工程框架对用户程序进行性能测试时，对工程配置进行一定的修改，例如

* 切换Debug配置，确保用户程序可以正确运行
* 使用perf_counter进行所需的的性能测试，并添加输入输出
* 切换Release配置，测试能获得的最高性能（或其他结果）

样例设置请参以下文档：

link:perf_counter_addusercode_e2.adoc[e^2^studio - 基于perf_counter工程进行用户代码性能测试]

link:perf_counter_addusercode_mdk.adoc[Keil MDK - 基于perf_counter工程进行用户代码性能测试]

== perf_counter 的使用指南

perf_counter完整的说明可以参考link:https://github.com/GorgonMeducer/perf_counter[Github]代码库的文档，中文资料请参考作者的微信公众号文章 link:https://mp.weixin.qq.com/s/pSjphzHc79xaGylzS1dL8g[超级嵌入式系统“性能/时间”工具箱]。

本例程主要使用以下功能

* 调用 `perfc_init(false);` 初始化
* `get_system_ms()`、`get_system_us()` 获取自初始化后经过的时间
* `get_system_ticks()` 获取自初始化后经过的 CPU 周期数
* `+__cpu_perf__()+` 统计周期数+DCache Miss-Rate。但仅限使用 PMU 时可用
* `+__cycleof__()+` 统计周期数。例如，统计延时函数使用的完整 CPU 周期

一个简单例子如下：

[source,c,subs="verbatim,attributes"]
----
int64_t s = get_system_ms();
__cycleof__("100MS") {
    R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
}
int64_t e = get_system_ms();
printf("Using time: %lld ms", e - s);
----

输出结果

image::Snipaste_2026-01-13_11-20-19.png[role="thumb", width=600]


